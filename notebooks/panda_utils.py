import numpy as npimport osimport tifffilefrom typing import Listdef verify_pair_match(image_dir: str,                      mask_dir: str,                      mask_ext: str = "_mask.tiff") -> bool:    """    Verifies if every image file in the provided image directory has a corresponding mask file     in the mask directory. The mask file is expected to have the same name as the image file     but with a specified extension (default is '_mask.tiff').    Parameters:    ----------    image_dir : str        The directory containing image files.        mask_dir : str        The directory containing mask files.        mask_ext : str, optional (default is "_mask.tiff")        The extension of the mask files.         Returns:    -------    bool        Returns True if every image file has a corresponding mask file, otherwise returns False.             """        image_files = sorted(os.listdir(image_dir))    mask_files = sorted(os.listdir(mask_dir))        for file in image_files:        if file != '.DS_Store':              if file[:file.find(".")] + mask_ext not in mask_files:                return False          return Truedef verify_dim_match(image_dir: str,                     mask_dir: str,                     root_folder: str,                     image_subfolder: str,                     mask_subfolder: str,                     dims: List[int] = [0,1,2]) -> bool:    """    Verifies that each image and mask pair have the same dimensionality along the specified    list of dimension indexes in dims.         Parameters:    ----------    image_dir : str        The directory containing image files.        mask_dir : str        The directory containing mask files.        root_folder: str        The root folder containing the image and mask folders.         image_subfolder: str        The subfolder containing the image files.        mask_subfolder: str        The subfolder containing the mask files.         dims: List[int]        List of integers specifying dimensions and their values to check for match.         Default: [0,1,2]: each image and mask pair will be checked for a match at dimension indices [0,1,2]                                      Returns:    -------    bool        Returns True if the dimensionality of each image and mask pair matches along all of the         specified dimension indices, False otherwise            """        image_files = list(filter(lambda file: file != '.DS_Store', sorted(os.listdir(image_dir))))    mask_files = list(filter(lambda file: file != '.DS_Store', sorted(os.listdir(mask_dir))))        assert len(image_files) == len(mask_files)    dims = list(set(dims))        n_files = len(image_files)        for i in range(n_files):        img = tifffile.imread(os.path.join(root_folder, image_subfolder, image_files[i]))        mask = tifffile.imread(os.path.join(root_folder, mask_subfolder, mask_files[i]))                img_dim = img.shape        mask_dim = mask.shape                match = all([img_dim[d] == mask_dim[d] for d in dims])                if not match:            return False            return Truedef validate_three_channel_mask(mask: np.ndarray) -> bool:        """    Since the PANDA dataset masks have 3 channels, this is a basic    function to validate an input mask. Only one of the three channels    of the mask could be effectively used as the official mask of the    corresponding image.        Parameters:    ----------    mask : np.ndarray        Input three-channel mask with integer labels possibly ranging from 0-5        across one or all channels        For the Radboud study of the PANDA dataset:        0: background (non tissue) or unknown        1: stroma (connective tissue, non-epithelium tissue)        2: healthy (benign) epithelium        3: cancerous epithelium (Gleason 3)        4: cancerous epithelium (Gleason 4)        5: cancerous epithelium (Gleason 5)        Returns:    -------    bool        Returns True if the three-channel mask is valid, False otherwise.        Validity criteria defined in the following cases.     """        # Verify that the mask to validate contains 3 channels    assert isinstance(mask, np.ndarray)    assert mask.shape[2] == 3        # Extract first, second, and third channels from the mask    first = mask[:, :, 0]    second = mask[:, :, 1]    third = mask[:, :, 2]        first_sum = first.sum()    second_sum = second.sum()    third_sum = third.sum()        assert first_sum >= 0 and second_sum >= 0 and third_sum >= 0            # Case 1: The mask indicates all background (contains only 0s)    # If all entries in all channels are 0, all channels will sum to 0        if (first_sum + second_sum + third_sum) == 0:        return True        # Case 2: The mask indicates non-zero signal and only one of the three channels    # is designated to express the non-zero signal    # Exactly one of the channels will sum to a number greater than 0    # While the other two channels will each sum to 0        if first_sum > 0 and (second_sum + third_sum == 0):        return True    if second_sum > 0 and (first_sum + third_sum == 0):        return True    if third_sum > 0 and (first_sum + second_sum == 0):        return True        # Case 3: The mask indicates non-zero signal and two channels are designated to    # express that non-zero signal. So two of the three channels must sum to a number     # greater than 0 and both of them should be identical        if first_sum > 0 and second_sum > 0 and np.all(first == second):        return True    if first_sum > 0 and third_sum > 0 and np.all(first == third):        return True    if second_sum > 0 and third_sum > 0 and np.all(second == third):        return True        # Case 4:     # The mask indicates non-zero signal and all of the three channels are designated    # to express that non-zero signal. So each of the three channels must sum to a number    # greater than 0 and all of them must be identical        if (first_sum == second_sum == third_sum) and np.all(first == second) and np.all(second == third):        return True        return Falsedef validate_mask_dir(mask_dir: str,                      root_folder: str,                      mask_subfolder: str) -> bool:        """    Validate all masks in mask directory using    validate_three_channel_mask        Parameters:    ----------    mask_dir : str        The directory containing mask files.        root_folder : str        The directory containing the mask folder.        mask_subfolder : str        The folder containing the masks.             Returns:    -------    bool        Returns True if all masks in directory are valid        according to validate_three_channel_mask            """        mask_files = list(filter(lambda file: file != '.DS_Store', sorted(os.listdir(mask_dir))))        for file in mask_files:        mask = tifffile.imread(os.path.join(root_folder, mask_subfolder, file))        if not validate_three_channel_mask(mask):            return False    return True